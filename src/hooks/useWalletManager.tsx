import { useState, useEffect, useCallback } from 'react';
import { ethers } from 'ethers';
import {
  UnlinkerWallet,
  WalletSession,
  requestUnlinkerWallet,
  getSessionStatus,
  claimUnlinkerWallet,
  importWallet,
  signWalletRequest,
  generateWalletRequestMessage,
  storeWalletSession,
  getStoredWalletSession,
  storeEncryptedWallet,
  getStoredWalletSessions,
  removeWalletSession,
} from '../services/walletManager';
import { EscrowPoolService } from '../services/escrowPool';
import { PerpDexService } from '../services/perpDex';

export interface WalletManagerState {
  // Main wallet (connected via MetaMask/etc)
  mainWallet?: ethers.Signer;
  mainAddress?: string;

  // Trading wallet (generated by privacy layer)
  tradingWallet?: ethers.Wallet;
  tradingAddress?: string;

  // Contract services
  escrowService?: EscrowPoolService;
  perpService?: PerpDexService;

  // Session management
  currentSession?: WalletSession;
  sessions: WalletSession[];

  // Contract state
  tokenBalance: string;
  tokenAllowance: string;
  needsApproval: boolean;

  // State
  isConnecting: boolean;
  isRequestingWallet: boolean;
  isClaimingWallet: boolean;
  isApproving: boolean;
  isDepositing: boolean;
  error: string | null;
}

interface UseWalletManagerReturn extends WalletManagerState {
  // Actions
  connectMainWallet: () => Promise<void>;
  disconnectWallet: () => void;
  requestPrivateWallet: () => Promise<string>;
  checkSessionStatus: (sessionId: string) => Promise<void>;
  claimPrivateWallet: (sessionId: string, password: string) => Promise<void>;
  switchToTradingWallet: (sessionId: string, password: string) => Promise<void>;
  refreshSessions: () => void;
  removeSession: (sessionId: string) => void;

  // Contract actions
  approveTokens: (amount: string) => Promise<void>;
  depositToEscrow: (amount: string) => Promise<void>;
  refreshTokenData: () => Promise<void>;
}

export function useWalletManager(): UseWalletManagerReturn {
  const [state, setState] = useState<WalletManagerState>({
    sessions: [],
    tokenBalance: '0',
    tokenAllowance: '0',
    needsApproval: false,
    isConnecting: false,
    isRequestingWallet: false,
    isClaimingWallet: false,
    isApproving: false,
    isDepositing: false,
    error: null,
  });

  // Load stored sessions on mount
  useEffect(() => {
    const sessions = getStoredWalletSessions();
    setState(prev => ({ ...prev, sessions }));
  }, []);

  const setError = useCallback((error: string | null) => {
    setState(prev => ({ ...prev, error }));
  }, []);

  const connectMainWallet = useCallback(async () => {
    if (!window.ethereum) {
      setError('MetaMask or compatible wallet not found');
      return;
    }

    setState(prev => ({ ...prev, isConnecting: true, error: null }));

    try {
      const provider = new ethers.BrowserProvider(window.ethereum);
      await provider.send('eth_requestAccounts', []);

      const signer = await provider.getSigner();
      const address = await signer.getAddress();

      // Initialize contract services
      const escrowService = new EscrowPoolService(provider, signer);
      const perpService = new PerpDexService(provider, signer);

      setState(prev => ({
        ...prev,
        mainWallet: signer,
        mainAddress: address,
        escrowService,
        perpService,
        isConnecting: false,
      }));

      // Refresh token data
      await refreshTokenDataInternal(escrowService, address);
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to connect wallet');
      setState(prev => ({ ...prev, isConnecting: false }));
    }
  }, [setError]);

  const refreshTokenDataInternal = async (escrowService: EscrowPoolService, address: string) => {
    try {
      const tokenInfo = await escrowService.getTokenInfo(address);
      const needsApproval = parseFloat(tokenInfo.allowance) === 0;

      setState(prev => ({
        ...prev,
        tokenBalance: tokenInfo.balance,
        tokenAllowance: tokenInfo.allowance,
        needsApproval,
      }));
    } catch (error) {
      console.error('Failed to refresh token data:', error);
    }
  };

  const disconnectWallet = useCallback(() => {
    setState(prev => ({
      ...prev,
      mainWallet: undefined,
      mainAddress: undefined,
      tradingWallet: undefined,
      tradingAddress: undefined,
      currentSession: undefined,
      error: null,
    }));
  }, []);

  const requestPrivateWallet = useCallback(async (): Promise<string> => {
    if (!state.mainWallet || !state.mainAddress) {
      throw new Error('Main wallet not connected');
    }

    setState(prev => ({ ...prev, isRequestingWallet: true, error: null }));

    try {
      // Generate and sign wallet request message
      const timestamp = Date.now();
      const message = generateWalletRequestMessage(state.mainAddress, timestamp);
      const signature = await signWalletRequest(state.mainWallet, message);

      // Request wallet from privacy layer
      const { sessionId } = await requestUnlinkerWallet(state.mainAddress, signature);

      // Create and store session
      const session: WalletSession = {
        sessionId,
        status: 'pending',
        depositAmount: '0',
        timestamp,
      };

      storeWalletSession(sessionId, session);

      setState(prev => ({
        ...prev,
        currentSession: session,
        sessions: [session, ...prev.sessions],
        isRequestingWallet: false,
      }));

      return sessionId;
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to request private wallet');
      setState(prev => ({ ...prev, isRequestingWallet: false }));
      throw error;
    }
  }, [state.mainWallet, state.mainAddress, setError]);

  const checkSessionStatus = useCallback(async (sessionId: string) => {
    try {
      const sessionData = await getSessionStatus(sessionId);

      // Update stored session
      storeWalletSession(sessionId, sessionData);

      // Update state
      setState(prev => ({
        ...prev,
        currentSession: prev.currentSession?.sessionId === sessionId ? sessionData : prev.currentSession,
        sessions: prev.sessions.map(s => s.sessionId === sessionId ? sessionData : s),
      }));
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to check session status');
    }
  }, [setError]);

  const claimPrivateWallet = useCallback(async (sessionId: string, password: string) => {
    setState(prev => ({ ...prev, isClaimingWallet: true, error: null }));

    try {
      // Claim the wallet from privacy layer
      const walletData = await claimUnlinkerWallet(sessionId);

      // Decrypt and import the wallet
      const tradingWallet = await importWallet(walletData.encryptedPrivateKey, password);

      // Store encrypted wallet data
      storeEncryptedWallet(walletData.address, walletData.encryptedPrivateKey);

      // Update session status
      const updatedSession: WalletSession = {
        sessionId,
        status: 'claimed',
        depositAmount: '0', // This should be updated from the actual deposit
        timestamp: Date.now(),
      };

      storeWalletSession(sessionId, updatedSession);

      setState(prev => ({
        ...prev,
        tradingWallet,
        tradingAddress: tradingWallet.address,
        currentSession: updatedSession,
        sessions: prev.sessions.map(s => s.sessionId === sessionId ? updatedSession : s),
        isClaimingWallet: false,
      }));
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to claim private wallet');
      setState(prev => ({ ...prev, isClaimingWallet: false }));
    }
  }, [setError]);

  const switchToTradingWallet = useCallback(async (sessionId: string, password: string) => {
    try {
      const session = state.sessions.find(s => s.sessionId === sessionId);
      if (!session) {
        throw new Error('Session not found');
      }

      if (session.status !== 'claimed') {
        await claimPrivateWallet(sessionId, password);
        return;
      }

      // Try to load existing wallet
      const storedSession = getStoredWalletSession(sessionId);
      if (storedSession) {
        // Note: This is a simplified version. In production, you'd need to
        // securely store and retrieve the decrypted private key or re-decrypt it
        setError('Please re-enter password to decrypt trading wallet');
      }
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to switch to trading wallet');
    }
  }, [state.sessions, claimPrivateWallet, setError]);

  const refreshSessions = useCallback(() => {
    const sessions = getStoredWalletSessions();
    setState(prev => ({ ...prev, sessions }));
  }, []);

  const removeSession = useCallback((sessionId: string) => {
    removeWalletSession(sessionId);
    setState(prev => ({
      ...prev,
      sessions: prev.sessions.filter(s => s.sessionId !== sessionId),
      currentSession: prev.currentSession?.sessionId === sessionId ? undefined : prev.currentSession,
    }));
  }, []);

  const approveTokens = useCallback(async (amount: string) => {
    if (!state.escrowService) {
      setError('Escrow service not initialized. Please connect wallet first.');
      return;
    }

    setState(prev => ({ ...prev, isApproving: true, error: null }));

    try {
      await state.escrowService.approveTokens(amount);

      // Refresh token data after approval
      if (state.mainAddress) {
        await refreshTokenDataInternal(state.escrowService, state.mainAddress);
      }

      setState(prev => ({ ...prev, isApproving: false }));
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to approve tokens');
      setState(prev => ({ ...prev, isApproving: false }));
    }
  }, [state.escrowService, state.mainAddress, setError]);

  const depositToEscrow = useCallback(async (amount: string) => {
    if (!state.escrowService) {
      setError('Escrow service not initialized. Please connect wallet first.');
      return;
    }

    setState(prev => ({ ...prev, isDepositing: true, error: null }));

    try {
      const result = await state.escrowService.deposit(amount);
      console.log('Deposit successful:', result);

      // Refresh token data after deposit
      if (state.mainAddress) {
        await refreshTokenDataInternal(state.escrowService, state.mainAddress);
      }

      setState(prev => ({ ...prev, isDepositing: false }));
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to deposit to escrow');
      setState(prev => ({ ...prev, isDepositing: false }));
    }
  }, [state.escrowService, state.mainAddress, setError]);

  const refreshTokenData = useCallback(async () => {
    if (!state.escrowService || !state.mainAddress) {
      return;
    }

    try {
      await refreshTokenDataInternal(state.escrowService, state.mainAddress);
    } catch (error) {
      console.error('Failed to refresh token data:', error);
    }
  }, [state.escrowService, state.mainAddress]);

  return {
    ...state,
    connectMainWallet,
    disconnectWallet,
    requestPrivateWallet,
    checkSessionStatus,
    claimPrivateWallet,
    switchToTradingWallet,
    refreshSessions,
    removeSession,
    approveTokens,
    depositToEscrow,
    refreshTokenData,
  };
}